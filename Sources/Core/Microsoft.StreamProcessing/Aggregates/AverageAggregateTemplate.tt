<#@ include file="AggregateTemplates.tt" #>
// *********************************************************************
// Copyright (c) Microsoft Corporation.  All rights reserved.
// Licensed under the MIT License
// *********************************************************************
using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;
using System.Numerics;
using System.Runtime.Serialization;

namespace Microsoft.StreamProcessing.Aggregates
{
    /// <summary>
    /// The state object used in average aggregates.
    /// </summary>
    /// <typeparam name="T">The type of the underlying elements being aggregated.</typeparam>
    [DataContract]
    public struct AverageState<T>
    {
        /// <summary>
        /// The sum of all data seen so far.
        /// </summary>
        [DataMember]
        public T Sum;

        /// <summary>
        /// The count of all events so far.
        /// </summary>
        [DataMember]
        public ulong Count;
    }
<#
    // Create average aggregates.
    foreach (var averageTypes in averageTypesToGenerate)
    {
        var typeFriendlyName = averageTypes.InputTypeFriendlyName;
        var typeName = averageTypes.TypeName;
        var sumTypeName = averageTypes.SumTypeName;
        var returnTypeName = averageTypes.ReturnTypeName;
#>

    internal sealed class Average<#= typeFriendlyName #>Aggregate : IAggregate<<#= typeName #>, AverageState<<#= sumTypeName #>>, <#= returnTypeName #>>
    {
        public Expression<Func<AverageState<<#= sumTypeName #>>>> InitialState()
            => () => default;

        public Expression<Func<AverageState<<#= sumTypeName #>>, long, <#= typeName #>, AverageState<<#= sumTypeName #>>>> Accumulate()
            => (oldState, timestamp, input) => new AverageState<<#= sumTypeName #>> { Count = oldState.Count + 1, Sum = oldState.Sum + input };

        public Expression<Func<AverageState<<#= sumTypeName #>>, long, <#= typeName #>, AverageState<<#= sumTypeName #>>>> Deaccumulate()
            => (oldState, timestamp, input) => new AverageState<<#= sumTypeName #>> { Count = oldState.Count - 1, Sum = oldState.Sum - input };

        public Expression<Func<AverageState<<#= sumTypeName #>>, AverageState<<#= sumTypeName #>>, AverageState<<#= sumTypeName #>>>> Difference()
            => (left, right) => new AverageState<<#= sumTypeName #>> { Count = left.Count - right.Count, Sum = left.Sum - right.Sum };

        public Expression<Func<AverageState<<#= sumTypeName #>>, AverageState<<#= sumTypeName #>>, AverageState<<#= sumTypeName #>>>> Sum()
            => (left, right) => new AverageState<<#= sumTypeName #>> { Count = left.Count + right.Count, Sum = left.Sum + right.Sum };

        public Expression<Func<AverageState<<#= sumTypeName #>>, <#= returnTypeName #>>> ComputeResult()
            => state => (<#= returnTypeName #>)state.Sum / state.Count;
    }

    internal sealed class AverageNullable<#= typeFriendlyName #>Aggregate : IAggregate<<#= typeName #>?, AverageState<<#= sumTypeName #>>, <#= returnTypeName #>?>
    {
        public Expression<Func<AverageState<<#= sumTypeName #>>>> InitialState()
            => () => default;

        public Expression<Func<AverageState<<#= sumTypeName #>>, long, <#= typeName #>?, AverageState<<#= sumTypeName #>>>> Accumulate()
            => (oldState, timestamp, input) => input.HasValue ? new AverageState<<#= sumTypeName #>> { Count = oldState.Count + 1, Sum = oldState.Sum + input.Value } : oldState;

        public Expression<Func<AverageState<<#= sumTypeName #>>, long, <#= typeName #>?, AverageState<<#= sumTypeName #>>>> Deaccumulate()
            => (oldState, timestamp, input) => input.HasValue ? new AverageState<<#= sumTypeName #>> { Count = oldState.Count - 1, Sum = oldState.Sum - input.Value } : oldState;

        public Expression<Func<AverageState<<#= sumTypeName #>>, AverageState<<#= sumTypeName #>>, AverageState<<#= sumTypeName #>>>> Sum()
            => (left, right) => new AverageState<<#= sumTypeName #>> { Count = left.Count + right.Count, Sum = left.Sum + right.Sum };

        public Expression<Func<AverageState<<#= sumTypeName #>>, AverageState<<#= sumTypeName #>>, AverageState<<#= sumTypeName #>>>> Difference()
            => (left, right) => new AverageState<<#= sumTypeName #>> { Count = left.Count - right.Count, Sum = left.Sum - right.Sum };

        public Expression<Func<AverageState<<#= sumTypeName #>>, <#= returnTypeName #>?>> ComputeResult()
            => state => state.Count != 0 ? (<#= returnTypeName #>)state.Sum / state.Count : (<#= returnTypeName #>?)null;
    }

    internal sealed class AverageFilterable<#= typeFriendlyName #>Aggregate : IAggregate<<#= typeName #>, AverageState<<#= sumTypeName #>>, <#= returnTypeName #>?>
    {
        public Expression<Func<AverageState<<#= sumTypeName #>>>> InitialState()
            => () => default;

        public Expression<Func<AverageState<<#= sumTypeName #>>, long, <#= typeName #>, AverageState<<#= sumTypeName #>>>> Accumulate()
            => (oldState, timestamp, input) => new AverageState<<#= sumTypeName #>> { Count = oldState.Count + 1, Sum = oldState.Sum + input };

        public Expression<Func<AverageState<<#= sumTypeName #>>, long, <#= typeName #>, AverageState<<#= sumTypeName #>>>> Deaccumulate()
            => (oldState, timestamp, input) => new AverageState<<#= sumTypeName #>> { Count = oldState.Count - 1, Sum = oldState.Sum - input };

        public Expression<Func<AverageState<<#= sumTypeName #>>, AverageState<<#= sumTypeName #>>, AverageState<<#= sumTypeName #>>>> Sum()
            => (left, right) => new AverageState<<#= sumTypeName #>> { Count = left.Count + right.Count, Sum = left.Sum + right.Sum };

        public Expression<Func<AverageState<<#= sumTypeName #>>, AverageState<<#= sumTypeName #>>, AverageState<<#= sumTypeName #>>>> Difference()
            => (left, right) => new AverageState<<#= sumTypeName #>> { Count = left.Count - right.Count, Sum = left.Sum - right.Sum };

        public Expression<Func<AverageState<<#= sumTypeName #>>, <#= returnTypeName #>?>> ComputeResult()
            => state => state.Count != 0 ? (<#= returnTypeName #>)state.Sum / state.Count : (<#= returnTypeName #>?)null;
    }
<#
    }
#>

    /// <summary>
    /// Extension methods to allow more aggregates
    /// </summary>
    public static partial class AggregateExtensions
    {
<#
    // Create average aggregates.
    foreach (var averageTypes in averageTypesNotBuiltIn)
    {
        var typeFriendlyName = averageTypes.InputTypeFriendlyName;
        var typeName = averageTypes.TypeName;
        var sumTypeName = averageTypes.SumTypeName;
        var returnTypeName = averageTypes.ReturnTypeName;
#>
        /// <summary>
        /// Performs an average of elements in a sequence
        /// </summary>
        /// <param name="enumerable">The sequence from which to compute the average</param>
        /// <returns>The average of all of the elements in the sequence</returns>
        [Aggregate(typeof(Average<#= typeFriendlyName #>Aggregate))]
        public static <#= returnTypeName #> Average(this IEnumerable<<#= typeName #>> enumerable)
            => enumerable
                .Aggregate(
                    Tuple.Create(0, (<#= sumTypeName #>)0),
                    (s, i) => Tuple.Create(s.Item1 + 1, (<#= sumTypeName #>)(s.Item2 + i)))
                .Yield().Select(s => (<#= returnTypeName #>)s.Item1 / (<#= returnTypeName #>)s.Item2).First();

        /// <summary>
        /// Performs an average of elements in a sequence
        /// </summary>
        /// <param name="enumerable">The sequence from which to compute the average</param>
        /// <returns>The average of all of the elements in the sequence</returns>
        [Aggregate(typeof(AverageNullable<#= typeFriendlyName #>Aggregate))]
        public static <#= returnTypeName #>? Average(this IEnumerable<<#= typeName #>?> enumerable)
            => enumerable
                .Aggregate(
                    Tuple.Create(0, (<#= sumTypeName #>)0),
                    (s, i) => i == null ? s : Tuple.Create(s.Item1 + 1, (<#= sumTypeName #>)(s.Item2 + i)))
                .Yield().Select(s => (<#= returnTypeName #>)s.Item1 / (<#= returnTypeName #>)s.Item2).First();

<#
    }
#>
    }
}
