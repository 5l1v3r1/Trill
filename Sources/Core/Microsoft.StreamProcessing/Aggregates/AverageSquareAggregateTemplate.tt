<#@ include file="AggregateTemplates.tt" #>
// *********************************************************************
// Copyright (c) Microsoft Corporation.  All rights reserved.
// Licensed under the MIT License
// *********************************************************************
using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;
using System.Numerics;

namespace Microsoft.StreamProcessing.Aggregates
{
<#
    // Create average aggregates.
    foreach (var averageTypes in averageTypesToGenerate)
    {
        var typeFriendlyName = averageTypes.InputTypeFriendlyName;
        var typeName = averageTypes.TypeName;
        var sumTypeName = averageTypes.SumTypeName;
        var returnTypeName = averageTypes.ReturnTypeName;
#>

    internal sealed class AverageSquare<#= typeFriendlyName #>Aggregate : IAggregate<<#= typeName #>, AverageState<<#= sumTypeName #>>, <#= returnTypeName #>>
    {
        public Expression<Func<AverageState<<#= sumTypeName #>>>> InitialState()
            => () => default;

        public Expression<Func<AverageState<<#= sumTypeName #>>, long, <#= typeName #>, AverageState<<#= sumTypeName #>>>> Accumulate()
            => (oldState, timestamp, input) => new AverageState<<#= sumTypeName #>> { Count = oldState.Count + 1, Sum = oldState.Sum + (<#= sumTypeName #>)(input * input) };

        public Expression<Func<AverageState<<#= sumTypeName #>>, long, <#= typeName #>, AverageState<<#= sumTypeName #>>>> Deaccumulate()
            => (oldState, timestamp, input) => new AverageState<<#= sumTypeName #>> { Count = oldState.Count - 1, Sum = oldState.Sum - (<#= sumTypeName #>)(input * input) };

        public Expression<Func<AverageState<<#= sumTypeName #>>, AverageState<<#= sumTypeName #>>, AverageState<<#= sumTypeName #>>>> Difference()
            => (left, right) => new AverageState<<#= sumTypeName #>> { Count = left.Count - right.Count, Sum = left.Sum - right.Sum };

        public Expression<Func<AverageState<<#= sumTypeName #>>, AverageState<<#= sumTypeName #>>, AverageState<<#= sumTypeName #>>>> Sum()
            => (left, right) => new AverageState<<#= sumTypeName #>> { Count = left.Count + right.Count, Sum = left.Sum + right.Sum };

        public Expression<Func<AverageState<<#= sumTypeName #>>, <#= returnTypeName #>>> ComputeResult()
            => state => (<#= returnTypeName #>)state.Sum / state.Count;
    }

    internal sealed class AverageSquareNullable<#= typeFriendlyName #>Aggregate : IAggregate<<#= typeName #>?, AverageState<<#= sumTypeName #>>, <#= returnTypeName #>?>
    {
        public Expression<Func<AverageState<<#= sumTypeName #>>>> InitialState()
            => () => default;

        public Expression<Func<AverageState<<#= sumTypeName #>>, long, <#= typeName #>?, AverageState<<#= sumTypeName #>>>> Accumulate()
            => (oldState, timestamp, input) => input.HasValue ? new AverageState<<#= sumTypeName #>> { Count = oldState.Count + 1, Sum = oldState.Sum + (<#= sumTypeName #>)(input.Value * input.Value) } : oldState;

        public Expression<Func<AverageState<<#= sumTypeName #>>, long, <#= typeName #>?, AverageState<<#= sumTypeName #>>>> Deaccumulate()
            => (oldState, timestamp, input) => input.HasValue ? new AverageState<<#= sumTypeName #>> { Count = oldState.Count - 1, Sum = oldState.Sum - (<#= sumTypeName #>)(input.Value * input.Value) } : oldState;

        public Expression<Func<AverageState<<#= sumTypeName #>>, AverageState<<#= sumTypeName #>>, AverageState<<#= sumTypeName #>>>> Sum()
            => (left, right) => new AverageState<<#= sumTypeName #>> { Count = left.Count + right.Count, Sum = left.Sum + right.Sum };

        public Expression<Func<AverageState<<#= sumTypeName #>>, AverageState<<#= sumTypeName #>>, AverageState<<#= sumTypeName #>>>> Difference()
            => (left, right) => new AverageState<<#= sumTypeName #>> { Count = left.Count - right.Count, Sum = left.Sum - right.Sum };

        public Expression<Func<AverageState<<#= sumTypeName #>>, <#= returnTypeName #>?>> ComputeResult()
            => state => state.Count != 0 ? (<#= returnTypeName #>)state.Sum / state.Count : (<#= returnTypeName #>?)null;
    }

    internal sealed class AverageSquareFilterable<#= typeFriendlyName #>Aggregate : IAggregate<<#= typeName #>, AverageState<<#= sumTypeName #>>, <#= returnTypeName #>?>
    {
        public Expression<Func<AverageState<<#= sumTypeName #>>>> InitialState()
            => () => default;

        public Expression<Func<AverageState<<#= sumTypeName #>>, long, <#= typeName #>, AverageState<<#= sumTypeName #>>>> Accumulate()
            => (oldState, timestamp, input) => new AverageState<<#= sumTypeName #>> { Count = oldState.Count + 1, Sum = oldState.Sum + (<#= sumTypeName #>)(input * input) };

        public Expression<Func<AverageState<<#= sumTypeName #>>, long, <#= typeName #>, AverageState<<#= sumTypeName #>>>> Deaccumulate()
            => (oldState, timestamp, input) => new AverageState<<#= sumTypeName #>> { Count = oldState.Count - 1, Sum = oldState.Sum - (<#= sumTypeName #>)(input * input) };

        public Expression<Func<AverageState<<#= sumTypeName #>>, AverageState<<#= sumTypeName #>>, AverageState<<#= sumTypeName #>>>> Sum()
            => (left, right) => new AverageState<<#= sumTypeName #>> { Count = left.Count + right.Count, Sum = left.Sum + right.Sum };

        public Expression<Func<AverageState<<#= sumTypeName #>>, AverageState<<#= sumTypeName #>>, AverageState<<#= sumTypeName #>>>> Difference()
            => (left, right) => new AverageState<<#= sumTypeName #>> { Count = left.Count - right.Count, Sum = left.Sum - right.Sum };

        public Expression<Func<AverageState<<#= sumTypeName #>>, <#= returnTypeName #>?>> ComputeResult()
            => state => state.Count != 0 ? (<#= returnTypeName #>)state.Sum / state.Count : (<#= returnTypeName #>?)null;
    }
<#
    }
#>

    /// <summary>
    /// Extension methods to allow more aggregates
    /// </summary>
    public static partial class AggregateExtensions
    {
<#
    // Create average of squares aggregates.
    foreach (var averageTypes in averageTypesToGenerate)
    {
        var typeFriendlyName = averageTypes.InputTypeFriendlyName;
        var typeName = averageTypes.TypeName;
        var sumTypeName = averageTypes.SumTypeName;
        var returnTypeName = averageTypes.ReturnTypeName;
#>
        /// <summary>
        /// Performs an average of squares of elements in a sequence
        /// </summary>
        /// <param name="enumerable">The sequence from which to compute the average of squares</param>
        /// <returns>The average of squares of all of the elements in the sequence</returns>
        [Aggregate(typeof(Average<#= typeFriendlyName #>Aggregate))]
        public static <#= returnTypeName #> AverageSquare(this IEnumerable<<#= typeName #>> enumerable)
            => enumerable
                .Aggregate(
                    Tuple.Create(0, (<#= sumTypeName #>)0),
                    (s, i) => Tuple.Create(s.Item1 + 1, (<#= sumTypeName #>)(s.Item2 + ((<#= sumTypeName #>)i * i))))
                .Yield().Select(s => (<#= returnTypeName #>)s.Item1 / (<#= returnTypeName #>)s.Item2).First();

        /// <summary>
        /// Performs an average of squares of elements in a sequence
        /// </summary>
        /// <param name="enumerable">The sequence from which to compute the average of squares</param>
        /// <returns>The average of squares of all of the elements in the sequence</returns>
        [Aggregate(typeof(AverageNullable<#= typeFriendlyName #>Aggregate))]
        public static <#= returnTypeName #>? AverageSquare(this IEnumerable<<#= typeName #>?> enumerable)
            => enumerable
                .Aggregate(
                    Tuple.Create(0, (<#= sumTypeName #>)0),
                    (s, i) => i == null ? s : Tuple.Create(s.Item1 + 1, (<#= sumTypeName #>)(s.Item2 + ((<#= sumTypeName #>)i * i))))
                .Yield().Select(s => (<#= returnTypeName #>)s.Item1 / (<#= returnTypeName #>)s.Item2).First();

<#
    }
#>
    }
}
