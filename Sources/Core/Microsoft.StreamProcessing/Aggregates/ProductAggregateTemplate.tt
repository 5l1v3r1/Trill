<#@ include file="AggregateTemplates.tt" #>
// *********************************************************************
// Copyright (c) Microsoft Corporation.  All rights reserved.
// Licensed under the MIT License
// *********************************************************************
using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;
using System.Numerics;

namespace Microsoft.StreamProcessing.Aggregates
{
<#
    // Create product aggregates (for non-nullable types).
    foreach (var sumTypes in sumTypesToGenerate)
    {
        var typeFriendlyName = sumTypes.InputTypeFriendlyName;
        var typeName = sumTypes.TypeName;
#>

    internal sealed class Product<#= typeFriendlyName #>Aggregate : IAggregate<<#= typeName #>, <#= typeName #>, <#= typeName #>>
    {
        public Expression<Func<<#= typeName #>>> InitialState() => () => 1;

        public Expression<Func<<#= typeName #>, long, <#= typeName #>, <#= typeName #>>> Accumulate()
            => (oldProduct, timestamp, input) => (<#= typeName #>)(oldProduct * input);

        public Expression<Func<<#= typeName #>, long, <#= typeName #>, <#= typeName #>>> Deaccumulate()
            => (oldProduct, timestamp, input) => (<#= typeName #>)(oldProduct / input);

        public Expression<Func<<#= typeName #>, <#= typeName #>, <#= typeName #>>> Difference()
            => (leftProduct, rightProduct) => (<#= typeName #>)(leftProduct / rightProduct);

        public Expression<Func<<#= typeName #>, <#= typeName #>, <#= typeName #>>> Sum()
            => (leftProduct, rightProduct) => (<#= typeName #>)(leftProduct * rightProduct);

        public Expression<Func<<#= typeName #>, <#= typeName #>>> ComputeResult() => product => product;
    }
<#
    }
#>

    /// <summary>
    /// Extension methods to allow more aggregates
    /// </summary>
    public static partial class AggregateExtensions
    {
<#
    // Create product aggregates (for non-nullable types).
    foreach (var sumTypes in sumTypesToGenerate)
    {
        var typeName = sumTypes.TypeName;
        var typeFriendlyName = sumTypes.InputTypeFriendlyName;
#>
        /// <summary>
        /// Performs a multiplication of all elements in a sequence
        /// </summary>
        /// <param name="enumerable">The sequence to multiply</param>
        /// <returns>The product of all of the elements in the sequence</returns>
        [Aggregate(typeof(Product<#= typeFriendlyName #>Aggregate))]
        public static <#= typeName #> Product(this IEnumerable<<#= typeName #>> enumerable)
            => enumerable.Aggregate((<#= typeName #>)1, (s, i) => (<#= typeName #>)(s * i));

<#
    }
#>
    }
}
