<#@ include file="AggregateTemplates.tt" #>
// *********************************************************************
// Copyright (c) Microsoft Corporation.  All rights reserved.
// Licensed under the MIT License
// *********************************************************************
using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;
using System.Numerics;

namespace Microsoft.StreamProcessing.Aggregates
{
<#
    // Create sum aggregates (for non-nullable types).
    foreach (var sumTypes in sumTypesToGenerate)
    {
        var typeFriendlyName = sumTypes.InputTypeFriendlyName;
        var typeName = sumTypes.TypeName;
#>

    internal sealed class Sum<#= typeFriendlyName #>Aggregate : IAggregate<<#= typeName #>, <#= typeName #>, <#= typeName #>>
    {
        public Expression<Func<<#= typeName #>>> InitialState() => () => 0;

        public Expression<Func<<#= typeName #>, long, <#= typeName #>, <#= typeName #>>> Accumulate()
            => (oldSum, timestamp, input) => (<#= typeName #>)(oldSum + input);

        public Expression<Func<<#= typeName #>, long, <#= typeName #>, <#= typeName #>>> Deaccumulate()
            => (oldSum, timestamp, input) => (<#= typeName #>)(oldSum - input);

        public Expression<Func<<#= typeName #>, <#= typeName #>, <#= typeName #>>> Difference()
            => (leftSum, rightSum) => (<#= typeName #>)(leftSum - rightSum);

        public Expression<Func<<#= typeName #>, <#= typeName #>, <#= typeName #>>> Sum()
            => (leftSum, rightSum) => (<#= typeName #>)(leftSum + rightSum);

        public Expression<Func<<#= typeName #>, <#= typeName #>>> ComputeResult() => sum => sum;
    }
<#
    }
#>

    /// <summary>
    /// Extension methods to allow more aggregates
    /// </summary>
    public static partial class AggregateExtensions
    {
<#
    // Create sum aggregates (for non-nullable types).
    foreach (var sumTypes in sumTypesNotBuiltIn)
    {
        var typeName = sumTypes.TypeName;
        var typeFriendlyName = sumTypes.InputTypeFriendlyName;
#>
        /// <summary>
        /// Performs a summation of all elements in a sequence
        /// </summary>
        /// <param name="enumerable">The sequence to add</param>
        /// <returns>The sum of all of the elements in the sequence</returns>
        [Aggregate(typeof(Sum<#= typeFriendlyName #>Aggregate))]
        public static <#= typeName #> Sum(this IEnumerable<<#= typeName #>> enumerable)
            => enumerable.Aggregate((<#= typeName #>)0, (s, i) => (<#= typeName #>)(s + i));

        /// <summary>
        /// Performs a summation of all elements in a sequence
        /// </summary>
        /// <param name="enumerable">The sequence to add</param>
        /// <returns>The sum of all of the elements in the sequence</returns>
        [Aggregate(typeof(Sum<#= typeFriendlyName #>Aggregate))]
        public static <#= typeName #>? Sum(this IEnumerable<<#= typeName #>?> enumerable)
            => enumerable.Aggregate((<#= typeName #>)0, (s, i) => i == null ? s : (<#= typeName #>)(s + i));

<#
    }
#>
    }
}
